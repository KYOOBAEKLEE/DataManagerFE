import { NextRequest } from 'next/server';

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

export interface FieldSpec {
    key: string;
    koreanName: string;
    description: string;
    sampleValue: string;
    type: string;
}

export interface PropertyAnalysis {
    property: string;
    structure: string;
    fields: FieldSpec[];
    rawData: unknown;
}

const ANALYSIS_PROMPT = `당신은 금융 데이터 분석 전문가입니다. Lipper API에서 반환된 JSON 데이터를 분석해주세요.

## 분석 요청
1. 데이터 구조를 트리 형태로 시각화 (인덴트 사용, 최대 3레벨)
2. 모든 하위 Key에 대해 명세 테이블 작성

## 출력 형식 (JSON만, 마크다운 없음)
{
  "structure": "트리 형태 구조 (문자열, 줄바꿈으로 계층 표현)",
  "fields": [
    {
      "key": "필드 경로 (예: data.attributes.name)",
      "koreanName": "한글 의미명",
      "description": "필드 역할 및 상세 설명 (한국어)",
      "sampleValue": "실제 데이터에서 추출한 예시값",
      "type": "string | number | boolean | array | object | null"
    }
  ]
}

## 주의사항
- 모든 leaf 노드를 포함해야 함
- 배열인 경우 첫 번째 요소의 구조 분석
- 한글명은 금융/펀드 도메인에 맞게 직관적으로
- 설명은 해당 필드가 무엇을 의미하는지 명확하게`;

async function analyzeWithGPT(property: string, data: unknown): Promise<{ structure: string; fields: FieldSpec[] }> {
    const dataStr = JSON.stringify(data, null, 2).slice(0, 15000);
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
            model: 'gpt-5.2',
            messages: [
                { role: 'system', content: ANALYSIS_PROMPT },
                { role: 'user', content: `Property: ${property}\n\nData:\n${dataStr}` }
            ],
            temperature: 0.2,
            max_completion_tokens: 8000,
        }),
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'OpenAI API error');
    }

    const result = await response.json();
    const content = result.choices[0]?.message?.content || '{}';
    
    try {
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
        }
    } catch {
        return { structure: 'Parse error', fields: [] };
    }
    
    return { structure: 'No data', fields: [] };
}

export async function POST(request: NextRequest) {
    const encoder = new TextEncoder();

    const stream = new ReadableStream({
        async start(controller) {
            const sendEvent = (event: string, data: unknown) => {
                controller.enqueue(encoder.encode(`data: ${JSON.stringify({ event, data })}\n\n`));
            };

            try {
                const { propertyResults } = await request.json();

                if (!propertyResults || !Array.isArray(propertyResults)) {
                    sendEvent('error', { message: 'propertyResults array is required' });
                    controller.close();
                    return;
                }

                const analyses: PropertyAnalysis[] = [];

                for (let i = 0; i < propertyResults.length; i++) {
                    const { property, data, error } = propertyResults[i];

                    sendEvent('progress', {
                        current: i + 1,
                        total: propertyResults.length,
                        property,
                        status: 'analyzing'
                    });

                    if (error || !data) {
                        analyses.push({
                            property,
                            structure: `Error: ${error || 'No data'}`,
                            fields: [],
                            rawData: null
                        });
                        continue;
                    }

                    try {
                        const { structure, fields } = await analyzeWithGPT(property, data);
                        
                        analyses.push({
                            property,
                            structure,
                            fields,
                            rawData: data
                        });

                        sendEvent('property_analyzed', {
                            current: i + 1,
                            total: propertyResults.length,
                            property,
                            fieldCount: fields.length
                        });
                    } catch (err) {
                        analyses.push({
                            property,
                            structure: `Analysis failed: ${err instanceof Error ? err.message : 'Unknown'}`,
                            fields: [],
                            rawData: data
                        });
                    }
                }

                sendEvent('complete', { analyses });
            } catch (error) {
                sendEvent('error', { 
                    message: error instanceof Error ? error.message : 'Analysis failed' 
                });
            } finally {
                controller.close();
            }
        }
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}
